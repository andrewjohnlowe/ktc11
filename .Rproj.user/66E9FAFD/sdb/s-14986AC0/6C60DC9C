{
    "collab_server" : "",
    "contents" : "#' Hello, world!\n#\n# This is an example function named 'hello'\n# which prints 'Hello, world!'.\n#\n# You can learn more about package authoring with RStudio at:\n#\n#   http://r-pkgs.had.co.nz/\n#\n# Some useful keyboard shortcuts for package authoring:\n#\n#   Build and Reload Package:  'Ctrl + Shift + B'\n#   Check Package:             'Ctrl + Shift + E'\n#   Test Package:              'Ctrl + Shift + T'\n\nhello <- function() {\n  print(\"Hello, world!\")\n}\n\n\n####              ####\n###  Data ingest   ###\n####              ####\n\n\n#' read_in_the_data\n#\n#\n#\n#' @importFrom readr read_csv\n#' @export\n#'\nread_in_the_data <- function(){\n\n # assuming we are in the /analysis/paper directory...\n\n # read in the c14 data\n ktc11_radiocarbon_dates <- read_csv(\"../data/ktc11_radiocarbon_dates.csv\")\n\n # read in the summary geoarch data\n ktc11_summary_geoarch_data <- read_csv(\"../data/ktc11_summary_geoarch_data.csv\")\n\n # read in the carbon isotope data\n ktc11_d13C_data <- read_csv(\"../data/ktc11_d13C_data.csv\")\n\n # read in the particle size data\n ktc11_particle_size_data <- read.csv(\"../data/ktc11_LPSA_data.txt\", header=FALSE, stringsAsFactors = FALSE)\n\n # read in the xrd data\n ktc11_summary_xrd_data <- read_csv(\"../data/ktc11_summary_xrd_data.csv\")\n\n # read in the icp data\n ktc11_raw_ICP_data <- read.csv(\"../data/ktc11_raw_ICP_data.csv\", header=TRUE, stringsAsFactors = FALSE)\n\n # read in the ceramic data\n ktc11_ceramic_data <- read_csv(\"../data/ktc11_ceramic_data.csv\")\n\n # read in the lithic data\n ktc11_lithic_data <- read_csv(\"../data/ktc11_lithic_data.csv\")\n\n # return a list of data frames\n return(list(ktc11_radiocarbon_dates = ktc11_radiocarbon_dates,\n             ktc11_summary_geoarch_data = ktc11_summary_geoarch_data,\n             ktc11_d13C_data = ktc11_d13C_data,\n             ktc11_particle_size_data = ktc11_particle_size_data,\n             ktc11_summary_xrd_data = ktc11_summary_xrd_data,\n             ktc11_raw_ICP_data = ktc11_raw_ICP_data,\n             ktc11_ceramic_data = ktc11_ceramic_data,\n             ktc11_lithic_data = ktc11_lithic_data ))\n}\n\n\n\n\n####              ####\n###   Chronology   ###\n####              ####\n\n\n# calibrate_the_dates\n#\n# This uses the Bchron package to calibrate\n# the radiocarbon dates\n#\n\n#' @importFrom Bchron BchronCalibrate\n#' @importFrom plyr ldply\n#' @export\n\ncalibrate_the_dates <- function(dates) {\n\n\n  dates_ <-  dates[-2,] # something wrong with the second date\n  # Bchron summary doesn't work well when range is >0 BP\n  set.seed(007)\n  ages <- BchronCalibrate(ages = dates_$RCAge,\n                          ageSds = dates_$RCAge_1s_error,\n                          positions = dates_$depth_below_surface,\n                          calCurves = rep(\"intcal13\", length(dates_$RCAge)))\n\n  # First create age samples for each date\n  age_samples = lapply(ages, function(x) sample(x$ageGrid,size=2000,replace=TRUE,prob=x$densities))\n  # Now summaries them with quantiles - this gives a 95% credible interval\n  df <- ldply(age_samples,quantile,prob=c(0.025,0.975))\n\n\n  # for our table we want\n  dates_table <- dates[, c(\"DAMS_Sample_code\",  \"RCAge\", \"RCAge_1s_error\",      \"Material\", \"spit\", \"depth_below_surface\")]\n  # add on calibrated ranges\n  # date 2 had a problem so let's do it by hand (from OxCal website)\n  df_ <- rbind( df[1,], c(291, 0), df[ 2:nrow(df),] )\n  dates_table <- cbind(dates_table, df_[,-1])\n\n  # change column names\n  names(dates_table) <- c(\"Sample code\", \"Age in years BP\", \"1 sd error\", \"Material dated\", \"Excavation unit\", \"Depth below surface (m)\", \"Calibrated upper 95%\", \"Calibrated lower 95%\")\n\n  # add a midpoint of calibrated dates for plotting\n  dates_table$midpoint <- with(dates_table, (`Calibrated upper 95%` - `Calibrated lower 95%`)/2 + `Calibrated lower 95%`)\n\n  return(dates_table)\n}\n\n\n\n\n# mean_difference_offset\n#\n# This computes an approximate mean difference in\n# the offset of the charcoal and shell dates\n#\n#' @importFrom Bchron Bchronology\n#' @importFrom dplyr arrange filter %>% inner_join\n#' @export\n\nmean_difference_offset <- function(dates) {\n  #\n  # we have to put in order to let the calibration work...\n  dates <- dates %>%\n    arrange(depth_below_surface)\n\n  # separate shell and charcoal dates to do separate interpolations\n  shell    <- dates %>% filter(Material == 'shell')\n  charcoal <- dates %>% filter(Material == 'charcoal')\n\n  # interpolate calibrated ages... rather slow\n  calibrated_dates_shell = Bchronology(ages = shell$RCAge,\n                                 ageSds = shell$RCAge_1s_error,\n                                 positions = shell$depth_below_surface,\n                                 positionThicknesses = 0.1,\n                                 ids = shell$depth_below_surface,\n                                 calCurves = rep(\"intcal13\", length(shell$RCAge)))\n\n  # interpolate calibrated ages... still slow\n  calibrated_dates_charcoal = Bchronology(ages = charcoal$RCAge,\n                                       ageSds = charcoal$RCAge_1s_error,\n                                       positions = charcoal$depth_below_surface,\n                                       positionThicknesses = 0.1,\n                                       ids = charcoal$depth_below_surface,\n                                       calCurves = rep(\"intcal13\", length(charcoal$RCAge)))\n\n  # get the first and last shell dates, since they have a shorter range than the\n  # charcoal dates\n  shell_first_last <- summary(calibrated_dates_shell)[c(1, nrow(summary(calibrated_dates_shell))),]\n\n  # get the charcoal ages from the same depths\n  calibrated_dates_charcoal_df <- summary(calibrated_dates_charcoal)\n  calibrated_dates_charcoal_df$Depth_rounded <- round(calibrated_dates_charcoal_df$Depth, 2)\n\n  # join so we have interpolated dates for charcoal to\n  # match the first and last shell date\n  shell_charcoal_offset <- inner_join(shell_first_last, calibrated_dates_charcoal_df,\n             by = c('Depth' = 'Depth_rounded'))\n\n  # compute the difference\n  mean_difference <- mean(shell_charcoal_offset$`50%.x` - shell_charcoal_offset$`50%.y`)\n\n\nreturn(mean_difference)\n\n}\n\n####              ####\n###   Geoarch      ###\n####              ####\n\n# join carbon isotope data to summary geoarch data\n#\n#\n#\n#' @importFrom dplyr group_by summarise %>%\n#' @export\n\njoin_carbon_to_summary <- function(ktc11_d13C_data, ktc11_summary_geoarch_data){\n\n  # compute means of measurements\n  ktc11_d13C_data_means <- ktc11_d13C_data %>%\n    group_by(SampleID) %>%\n    summarise(mean(`d13C vs VPDB (permil)`))\n\n  # row order must be B1, A2, A3, A4, A5, A6, A7H, 8, A7L\n  ktc11_d13C_data_means <- ktc11_d13C_data_means[c(9,1,2,3,4,5,6,8,7),]\n\n  # join to summary geoarch data\n  ktc11_summary_geoarch_data_dC13 <- cbind(ktc11_summary_geoarch_data, ktc11_d13C_data_means[,-1])\n\n  return(ktc11_summary_geoarch_data_dC13)\n\n\n\n}\n\n# particle_size_data_summary\n#\n#\n#\n#' @importFrom stringr str_extract\n#' @importFrom reshape2 dcast\n#' @importFrom G2Sd granstat\n#' @importFrom dplyr select %>% mutate_each funs\n#' @export\n\nparticle_size_data_summary <- function(ktc11_particle_size_data){\n\n  # This object \"ktc11_particle_size_data\" has the raw output from the instrument\n  # which means it has a lot of stuff we don't need. Let's\n  # delete the first row and first 23 columns to get only sample\n  # names, size classes and sample data. We're also removing\n  # column 25 and the very last column because they are empty\n  KTC_LPSA <- ktc11_particle_size_data[-1,-c(1:22, 25, ncol(ktc11_particle_size_data))]\n  #\n  # Fill first column with numbers and give it a name, this\n  # will be useful later\n  #\n  KTC_LPSA[,1] <- c(1:nrow(KTC_LPSA))\n  names(KTC_LPSA)[1]<-c(\"num\")\n  #\n  # Convert a few errant characters to numbers. This is a bug\n  # of the import process where some numbers are not\n  # formatted as numbers.\n  KTC_LPSA[,c(3:ncol(KTC_LPSA))] <- as.numeric(as.character(unlist(KTC_LPSA[,c(3:ncol(KTC_LPSA))])))\n  #\n  # Reshape to long form to prepare for statistical analysis,\n  # this may take a few seconds...\n  KTC_l <- reshape(KTC_LPSA, idvar=1:2,\n                   varying=list(size=colnames(KTC_LPSA[seq(from=3,\n                                                           to=ncol(KTC_LPSA), by=3)]),\n                                meas=colnames(KTC_LPSA[seq(from=4,\n                                                           to=ncol(KTC_LPSA), by=3)])),\n                   direction=\"long\")\n  #\n  # strip off the numbers indicating replicates of the same sample\n  # so we can use the sample ID as the group label for doing\n  # stats by groups\n  KTC_l$V24 <-  str_extract(KTC_l$V24, \".+[^[:punct:]{1}[:digit:]{1}[:punct:]{1}][^rs]\")\n  #\n  #\n  # get averages of multiple runs on the same sample\n  KTC_l_a <- aggregate(KTC_l$V27, list(sample=KTC_l$V24, size=KTC_l$V26), mean)\n  KTC_l_a <- subset(KTC_l_a, KTC_l_a$x != \"NA\")\n  #\n  # Rename measurement variable for consistency, ready for plots\n  # and tables\n  KTC_l_a$q <- KTC_l_a$x\n  #\n  # Put the sample names in order, first inspect the levels\n  # levels(as.factor(KTC_l_a$sample))\n  #\n  # now reorder them, I've already done the hard work for you\n  # here, just click through...\n  KTC_l_a$sample <- factor(as.factor(KTC_l_a$sample),\n                           levels(as.factor(KTC_l_a$sample))\n                           [c(9,1,2,3,4,5,7,8,6)])\n  #\n  # Check that it worked ok, the sample names should be in\n  # order now\n  # levels(KTC_l_a$sample)\n  #\n  # Now we are ready to visualise the LPSA data. We'll look at\n  # how to do all samples together, then just one by itself.\n  #\n  # Make a plot to have a quick look, all samples overlaid\n  # library(ggplot2)\n  # ggplot(KTC_l_a, aes(group = sample))+ geom_line(aes(x=size, y=q, colour = sample))\n  #\n  # And for a different perspective, plot each sample\n  # separately, one above the other\n  # ggplot(KTC_l_a, aes(size, q)) + geom_line() + facet_grid(sample ~ .)\n  #\n  # Plot an individual sample, go ahead and change the\n  # sample name to get different samples\n  # ggplot(subset(KTC_l_a, KTC_l_a == \"KTC_A6\"),\n  #       aes(size, q)) + geom_line()\n  #\n  # Now we can do some basic statistical analysis of the LPSA\n  # data. We will use a package dedicated to granulometry to\n  # calculate typical summary statistics of particle sizes.\n  #\n  # First we need to get the data in the shape that the grain\n  # size stats package is expecting. Let's cast into a wide\n  # table of sample by size class.\n  #\n  #\n  KTC_l_a <- KTC_l_a[ order(-KTC_l_a$size), ]\n  KTC_cast <- t(dcast(KTC_l_a, sample ~ size, value.var=\"q\"))\n  colnames(KTC_cast) <- KTC_cast[1,]\n  KTC_cast <- KTC_cast[-1,]\n  #\n  # We need to add an empty row at the bottom to\n  # make the stats work\n  z <- c(rep(0, ncol(KTC_cast)))\n  KTC_cast <- data.frame(rbind(KTC_cast,z))\n  rownames(KTC_cast)[nrow(KTC_cast)] <- c(\"0\")\n  KTC_cast[,1:ncol(KTC_cast)] <- as.numeric(as.character(unlist(KTC_cast[,1:ncol(KTC_cast)])))\n  #\n  #\n  # This next line will make a table of commonly used\n  # grain size stats. Note that when modes is set to TRUE,\n  # then you have to use mouse to click on the modal\n  # point for each plot, then press escape to move on to\n  # the next sample's plot. Currently I've set the function\n  # to modes=FALSE so you don't have to worry about that.\n  # After the last sample all the data will be generated.\n  # Definitions of the  terms used can be found here\n  # http://cran.r-project.org/web/packages/G2Sd/G2Sd.pdf or by\n  # typing ?granstat at the R prompt\n  KTC_granstat <- as.data.frame(t(granstat(KTC_cast, statistic = \"arithmetic\", aggr = TRUE, modes = FALSE)))\n\n  # Let's get just the mean and standard deviation from the\n  # particle size data ready to attach it to the table of\n  # basic sediment data to make a stratigraphic plot\n\n  particle_size_data_summary_subset <- KTC_granstat %>%\n    # subset only mean and sd cols\n    dplyr::select(mean.arith.um, sd.arith.um) %>%\n    # convert from factor to numeric\n    mutate_each(dplyr::funs(as.character), mean.arith.um, sd.arith.um) %>%\n    mutate_each(dplyr::funs(as.numeric), mean.arith.um, sd.arith.um)\n  particle_size_data_summary_subset$`Sample ID`  <- row.names(particle_size_data_summary)\n\n  return(list(KTC_granstat = KTC_granstat,\n              particle_size_data_summary_subset = particle_size_data_summary_subset))\n\n}\n\n\n\n#' icp_aes_data_summary\n#'\n#'\n#'\n#' @importFrom tidyr spread\n#' @export\n#'\nicp_aes_data_summary <- function(ktc11_raw_ICP_data){\n\n  # ktc11_raw_ICP_data  <- the_data$ktc11_raw_ICP_data\n\n  KTC_ICP <- ktc11_raw_ICP_data\n  #\n  # This object \"KTC_ICP\" that we just made has data for both KTC\n  # and BN1. Let's split it up so you can choose which site\n  # you want to do the rest of the analysis on. This line\n  # returns only those rows that have \"KTC\" in the Sample.ID\n  # We'll come back to the replicates and blanks later\n  #\n\n\n  KTConly <- KTC_ICP[grepl(\"KTC\", KTC_ICP$Sample.ID) &\n                       !grepl(\"BLANK|Blank\", KTC_ICP$Sample.ID) &\n                       !grepl(\"replica\", KTC_ICP$Sample.ID), ]\n\n  # KTConly <- KTC_ICP %>%\n  #             filter(grepl(\"KTC\", Sample.ID)) %>%\n  #             filter(!grepl(\"BLANK|Blank\", Sample.ID)) %>%\n  #             filter(!grepl(\"replica\", Sample.ID))\n\n  # KTConly <- subset(KTC_ICP, (grepl(\"KTC\", KTC_ICP$Sample.ID)))\n  # # but still has blanks\n  # KTConly <- subset(KTConly, !(grepl(\"BLANK|Blank\", KTConly$Sample.ID)))\n  # # no blanks now\n  # KTConly <- subset(KTConly, !(grepl(\"replica\", KTConly$Sample.ID)))\n  # # no replicates\n  #\n  #\n  # And let's put all the blanks in one data object\n  # to look at together\n  blanks <- KTC_ICP[grepl(\"BLANK|Blank\", KTC_ICP$Sample.ID), ]\n\n  replicates <- KTC_ICP[grepl(\"replica\", KTC_ICP$Sample.ID), ]\n\n  # blanks <- subset(KTC_ICP, grepl(\"BLANK|Blank\", KTC_ICP$Sample.ID))\n  # # and the replicates, ready for later\n  # replicates <- subset(KTC_ICP, (grepl(\"replica\", KTC_ICP$Sample.ID)))\n\n  #\n  #\n  # convert the mg/L values, first make change them ppm to\n  # ppb, then make sure they're all +ve, then take the\n  # base 10 log, and put that new value into a new column\n  KTConly$LogConc <- log10(abs(KTConly$Conc..Samp.1*1000))\n  #\n  # # plot all the samples on top of each other, may take 5 seconds...\n  # # a fairly pointless plot, hard to see differences...\n  # ggplot(data=KTConly, aes(group = Sample.ID)) +\n  #   geom_line(aes(x=Elem, y=LogConc, colour = Sample.ID))\n  #\n  # get ready to plot each sample separately by making a small table of just\n  # sample ID, element and log concentration, and then exlude rows with NA\n  KTCconcs <- as.data.frame(na.omit(cbind(KTConly$Sample.ID,\n                                          KTConly$Elem, KTConly$LogConc)))\n\n\n  # KTCconcs <- as.data.frame(na.omit(cbind(as.matrix(KTConly$Sample.ID),\n  #                                         as.matrix(KTConly$Elem), KTConly$LogConc)))\n  # give column names back again\n  colnames(KTCconcs) <- c(\"Sample.ID\", \"Element\", \"log_ugL\")\n  #\n  # convert mg.L from factor to numeric, ready to operate on\n  KTCconcs$log_ugL <- abs(as.numeric(as.character(KTCconcs$log_ugL)))\n  #\n  # convert \"NA\" to zeros, \"NA\" comes from elements that were so high\n  # in concentration that they saturated the detector and we have no\n  # data on them at all. We can re-run the sample with different\n  # settings to get data if necessary.\n  KTCconcs$log_ugL <- as.numeric(ifelse(KTCconcs$log_ugL==\"NA\",\n                                        \"0\", KTCconcs$log_ugL))\n  #\n  # convert \"Inf\" to zero. These come from the log of a\n  # negative number. The negative numbers result from\n  # spectral interference during calibration\n  KTCconcs$log_ugL <- as.numeric(ifelse(KTCconcs$log_ugL==\"Inf\",\n                                        \"0\", KTCconcs$log_ugL))\n  #\n  # re-order the sample IDs to get them in stratigraphic order\n  # so they plot in that order...\n  # first, find out what order they are in\n  # levels(KTCconcs$Sample.ID)\n  # second, reorder them, I have already determined the correct\n  # order here, so it should just work when you click though\n  KTCconcs$Sample.ID <- factor(KTCconcs$Sample.ID,\n                               levels(KTCconcs$Sample.ID)[c(9,2,3,1,4,5,6,8,7)])\n  # check that you reordered them correctly\n  # levels(KTCconcs$Sample.ID)\n  #\n  # Now we are going to go through a few visualisation methods\n  # to try and get a look at the data and see if we can spot\n  # trends and interesting patterns.\n  #\n  # First, plot all of the samples in a giant grid of plots...\n  # this may be very slow! Could be a couple of mins...\n  # ggplot(KTCconcs, aes(Element, log_ugL)) + geom_point() +\n  #   facet_wrap( ~ Sample.ID)\n  # #\n  # # Second, let's try a single column of plots\n  # ggplot(KTCconcs, aes(Element, log_ugL)) + geom_point() +\n  #   facet_grid(Sample.ID ~ .)\n  #\n  # Third, let's rotate the plot to make a stratigraphic plot\n  # with the samples in order from top to bottom\n  #\n  # We need to convert data to wide format for this plot\n  # KTCconcs$row <- 1:nrow(KTCconcs)\n  # KTCconcs$row <- NULL\n  KTCcast <-  spread(KTCconcs, Element, log_ugL)\n\n\n  # KTCcast_dcast <- dcast(KTCconcs, as.character(Sample.ID) ~ as.character(Element), value.var=\"log_ugL\")\n  #\n  # get rid of sample IDs by putting them into rownames\n  row.names(KTCcast) <- KTCcast$Sample.ID\n  #\n  # delete sample ID column\n  KTCcast <- KTCcast[,-1]\n  #\n  # delete columns with zeros, these elements with problematic data\n  # resulting from calibration problems or saturation of the\n  # detector\n  KTCcast <- KTCcast[,!(colSums(abs(KTCcast)) == 0)]\n  #\n  # load the packages we need to make the stratigraphic plot\n  # library(analogue)\n  #\n  # make a data object that contains that sample depth\n  # values in m below the surface\n  depths <- c(0.02, 0.09, 0.22, 0.30, 0.40, 0.53, 0.72, 0.92, 1.10)\n  #\n  KTCcast.strat <- KTCcast\n  #\n  # And now draw the plot...\n  # Stratiplot(KTCcast.strat, y = depths,\n  #            type = c(\"h\", \"o\"), ylab = \"depth below surface (m)\",\n  #            varTypes = \"absolute\")\n  # #\n  # This is a bit of a silly plot, there's too much going on.\n  # But you might be able to spot some trends that you want to\n  # make a note of to explore futher by plotting just a subset\n  # of all the elements.\n  #\n  # To plot just a subset of certain elements, try this.\n  # you can add as many elements as you like by\n  # inserting more 'which(colnames(KTCcast.strat)==\"Na\")'\n  # and just changing the element name. Don't forget the\n  # comma after the close-bracket! You should go ahead and\n  # replace the element names here with ones that you've found\n  # to have interesting patterns.\n  # Stratiplot(KTCcast.strat[,c(which(colnames(KTCcast.strat)==\"Sc\"), # delete or copy\n  #                             which(colnames(KTCcast.strat)==\"V\"), # these lines to\n  #                             which(colnames(KTCcast.strat)==\"Li\"),  # customise as\n  #                             which(colnames(KTCcast.strat)==\"Cr\"),  # customise as\n  #                             which(colnames(KTCcast.strat)==\"Ni\"),  # customise as\n  #                             which(colnames(KTCcast.strat)==\"Na\")   # you like\n  # ) ],\n  # y = depths, type = c(\"h\", \"o\"), ylab = \"depth below surface (m)\",\n  # varTypes = \"absolute\")\n  # #\n\n# get table of ppm of many elements (cols) for each context (rows)\n\n  # subset elements of interest\n  subset_elements <- c(\"Ca\", \"Sr\", \"Mn\", \"Fe\", \"Zn\",  \"Na\", \"K\", \"Mg\", \"Ti\")\n  KTCcast.strat.subset <- KTCcast.strat[ , names(KTCcast.strat) %in% subset_elements]\n\nreturn(KTCcast.strat.subset)\n\n}\n\n####                  ####\n###   Archaeology      ###\n####                  ####\n\n\n#' table_ceramics_lithics\n#'\n#' @importFrom dplyr group_by %>% full_join\n#' @export\n#'\ntable_ceramics_lithics <- function(lithics, ceramics){\n\n  # lithics <- the_data$ktc11_lithic_data\n  # ceramics <- the_data$ktc11_ceramic_data\n\n\n# aggregate counts and masses per context\n\n  li <- lithics %>%\n    group_by(Context) %>%\n    dplyr::summarise(lithic_counts = sum(Counts),\n                     lithic_mass = sum(Mass))\n\n  ce <- ceramics %>%\n    group_by(Context) %>%\n    dplyr::summarise(ceramic_counts = sum(Counts),\n                     ceramic_mass = sum(Mass))\n\n   ktc11_summary_ceramics_lithics <-  full_join(li, ce, by  = \"Context\")\n\n   # meaningful column names\n   names(ktc11_summary_ceramics_lithics) <- c('Context', \"Lithic count (n)\", \"Lithic mass (g)\", \"Ceramic count (n)\", \"Ceramic mass (g)\")\n\n   # reorder so that it's in the correct order\n   ktc11_summary_ceramics_lithics_reordered <- ktc11_summary_ceramics_lithics[c(1,8,9,2,3,4,5,7,6), ]\n\n   return(ktc11_summary_ceramics_lithics_reordered)\n\n\n}\n\n\n\n\n#'  long_corr_matrix\n#\n#\n# from http://www.sthda.com/english/wiki/correlation-matrix-a-quick-start-guide-to-analyze-format-and-visualize-a-correlation-matrix-using-r-software\n# cormat : matrix of the correlation coefficients\n# pmat : matrix of the correlation p-values\n#\n#' @importFrom Hmisc rcorr\n#' @export\n#'\nlong_corr_matrix <- function(df) {\n  res <- rcorr(as.matrix(df))\n  cormat <- res$r\n  pmat <- res$P\n  ut <- upper.tri(cormat)\n  data.frame(\n    row = rownames(cormat)[row(cormat)[ut]],\n    column = rownames(cormat)[col(cormat)[ut]],\n    cor  =(cormat)[ut],\n    p = pmat[ut]\n  )\n}\n",
    "created" : 1452036170983.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "527529849",
    "id" : "6C60DC9C",
    "lastKnownWriteTime" : 1452232156,
    "last_content_update" : 1452232156952,
    "path" : "G:/My Documents/My Papers/Journal of Archaeological Science/Marwick, Conrad, et al. 2015/ktc11/R/functions.R",
    "project_path" : "R/functions.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}